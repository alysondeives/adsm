/* Copyright (c) 2011 University of Illinois
                   Universitat Politecnica de Catalunya
                   All rights reserved.

Developed by: IMPACT Research Group / Grup de Sistemes Operatius
              University of Illinois / Universitat Politecnica de Catalunya
              http://impact.crhc.illinois.edu/
              http://gso.ac.upc.edu/

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to
deal with the Software without restriction, including without limitation the
rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
  1. Redistributions of source code must retain the above copyright notice,
     this list of conditions and the following disclaimers.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimers in the
     documentation and/or other materials provided with the distribution.
  3. Neither the names of IMPACT Research Group, Grup de Sistemes Operatius,
     University of Illinois, Universitat Politecnica de Catalunya, nor the
     names of its contributors may be used to endorse or promote products
     derived from this Software without specific prior written permission.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
WITH THE SOFTWARE.  */


#ifndef __cplusplus
#error "This header can only be included in C++ programs"
#endif

#ifndef GMAC_OPENCL_CPP_H_
#define GMAC_OPENCL_CPP_H_

#include <string>
#include <istream>

#include "opencl.h"

namespace ocl {

typedef ocl_error error;

typedef ocl_memory_hint memory_hint;
typedef ocl_protection protection;

class kernel {
private:
    ocl_kernel kernel_;

    template <typename T>
    struct Param {
        T value_;
        Param(T init) :
            value_(init)
        {
        }
    };

    template <typename T>
    struct Param<T *> {
        cl_mem value_;
        Param(T *init) :
            value_(oclPtr(init))
        {
        }
    };

    inline
    error getByName(std::string name)
    {
        error ret = ::oclKernelGet(name.c_str(), &kernel_);
        return ret;
    }

    inline
    kernel()
    {
    }

    inline
    kernel(const char *name)
    {
        get(name);
    }

public:
    inline static
    kernel *get(std::string name)
    {
        kernel *launch = new kernel();
        if (launch->getByName(name) == oclSuccess) return launch;
        delete launch;
    }

    inline
    kernel(std::string name, error &err)
    {
        err = oclSuccess;
        if (getByName(name) != oclSuccess) err = oclErrorInvalidKernelName;
    }

    inline
    ~kernel()
    {
        oclKernelDestroy(kernel_);
    }

    inline
    ocl::kernel &operator=(const kernel &launch)
    {
        kernel_ = launch.kernel_;
        return *this;
    }

    inline
    error setArg(unsigned index, const void *addr, size_t size)
    {
        return ::oclKernelSetArg(kernel_, index, addr, size);
    } 

    template <typename T>
    inline
    error setArg(unsigned index, T val)
    {
        Param<T> p(val);
        return ::oclKernelSetArg(kernel_, index, &p.value_, sizeof(p.value_));
    }

    /**
     * Launches a kernel execution
     *
     * \param workDim
     * \param globalWorkOffset
     * \param globalWorkSize
     * \param localWorkSize
     */
    inline
    error launch(size_t workDim, size_t *globalWorkOffset,
                 size_t *globalWorkSize, size_t *localWorkSize)
    {
        error ret = ::oclKernelLaunch(kernel_, workDim, globalWorkOffset, globalWorkSize, localWorkSize);
        return ret;
    }

    inline
    error callNDRange(size_t workDim, size_t *globalWorkOffset,
                      size_t *globalWorkSize, size_t *localWorkSize)
    {
        error ret = launch(workDim, globalWorkOffset, globalWorkSize, localWorkSize);
        return ret;
    }

#ifdef __GXX_EXPERIMENTAL_CXX0X__
private:
    template <typename P1, typename ...Pn>
    error __launch(size_t workDim, size_t *globalWorkOffset,
                   size_t *globalWorkSize, size_t *localWorkSize, 
                   unsigned index, P1 p1, Pn ...pn)
    {
        error ret = setArg(index, p1);
        if (ret != gmacSuccess) return ret;
        return __launch(workDim, globalWorkOffset, globalWorkSize, localWorkSize, index + 1, pn...);
    }

    error __launch(size_t workDim, size_t *globalWorkOffset,
                   size_t *globalWorkSize, size_t *localWorkSize, unsigned index)
    {
        return ::oclKernelLaunch(kernel_, workDim, globalWorkOffset, globalWorkSize, localWorkSize);
    }

public:
    template <typename P1, typename ...Pn>
    error launch(size_t workDim, size_t *globalWorkOffset,
                 size_t *globalWorkSize, size_t *localWorkSize,
                 P1 p1, Pn ...pn)
    {
        return __launch(workDim, globalWorkOffset, globalWorkSize, localWorkSize, 0, p1, pn...);
    }

    template <typename P1, typename ...Pn>
    error callNDRange(size_t workDim, size_t *globalWorkOffset,
                      size_t *globalWorkSize, size_t *localWorkSize,
                      P1 p1, Pn ...pn)
    {
        return launch(workDim, globalWorkOffset, globalWorkSize, localWorkSize, p1, pn...);
    }

#endif
#if 0
    inline
    error wait()
    {
        return ::__oclKernelWait(&kernel_);
    }
#endif
};

/**
 * Prepares the OpenCL code to be used by the applications 
 * \param code Pointer to the NULL-terminated string that contains the code
 * \param flags Compilation flags or empty string
 */
static inline error compileSource(std::string code, std::string flags = "")
{
    return ::oclCompileSource(code.c_str(), flags.c_str());
}

/**
 * Prepares the OpenCL code to be used by the applications 
 * \param path String with the path of the file that contains the code
 * \param flags Compilation flags or empty string
 */
static inline error compileSourceFile(std::string path, std::string flags = "")
{
    return ::oclCompileSourceFile(path.c_str(), flags.c_str());
}

/**
 * Prepares the OpenCL code to be used by the applications 
 * \param in Input stream that reads the code
 * \param flags Compilation flags or empty string
 */
static inline error compileSourceStream(std::istream &in, std::string flags = "")
{
    if (!in.good()) return gmacErrorInvalidValue;
    in.seekg (0, std::ios::end);
    std::streampos length = in.tellg();
    in.seekg (0, std::ios::beg);
    if (length == std::streampos(0)) return gmacSuccess;
    // Allocate memory for the code
    char *buffer = new char[int(length)+1];
    // Read data as a block
    in.read(buffer,length);
    buffer[length] = '\0';
    error ret = ::oclCompileSource(buffer, flags.c_str());
    delete [] buffer;
    return ret;
}

/**
 * Prepares the OpenCL binary to be used by the applications 
 * \param binary Pointer to the array that contains the binary code
 * \param size Size in bytes of the array that contains the binary code
 * \param flags Compilation flags or empty string
 */
static inline error compileBinary(const unsigned char *binary, size_t size, std::string flags = "")
{
    return ::oclCompileBinary(binary, size, flags.c_str());
}

/**
 * Prepares the OpenCL binary code to be used by the applications 
 * \param path String with the path of the file that contains the binary code
 * \param flags Compilation flags or empty string
 */
static inline error compileBinaryFile(std::string path, std::string flags = "")
{
    return ::oclCompileBinaryFile(path.c_str(), flags.c_str());
}

/**
 * Prepares the OpenCL code to be used by the applications 
 * \param in Input stream that reads the code
 * \param flags Compilation flags or empty string
 */
static inline error compileBinaryStream(std::istream &in, std::string flags = "")
{
    if (!in.good()) return gmacErrorInvalidValue;
    in.seekg (0, std::ios::end);
    std::streampos length = in.tellg();
    in.seekg (0, std::ios::beg);
    if (length == std::streampos(0)) return gmacSuccess;
    // Allocate memory for the code
    unsigned char *buffer = new unsigned char[int(length)+1];
    // Read data as a block
    in.read((char *) buffer,length);
    buffer[length] = '\0';
    error ret = ::oclCompileBinary(buffer, length, flags.c_str());
    delete [] buffer;
    return ret;
}


/* Wrappers to GMAC native calls */
static inline
unsigned getNumberOfAccelerators() { return ::oclGetNumberOfAccelerators(); }

static inline
size_t getFreeMemory() { return ::oclGetFreeMemory(); }

static inline
error migrate(unsigned acc) { return ::oclMigrate(acc); }

static inline
ocl_error memoryMap(void *cpuPtr, size_t count, protection prot) {
    return ::oclMemoryMap(cpuPtr, count, prot);
}

static inline
ocl_error memoryUnmap(void *cpuPtr, size_t count) { return ::oclMemoryUnmap(cpuPtr, count); }

static inline
ocl_error malloc(void **devPtr, size_t count) { return ::oclMalloc(devPtr, count); }

static inline
ocl_error globalMalloc(void **devPtr, size_t count, memory_hint hint = OCL_GLOBAL_MALLOC_CENTRALIZED) {
    return ::oclGlobalMalloc(devPtr, count, hint);
}

static inline
ocl_error free(void *cpuPtr) { return ::oclFree(cpuPtr); }

static inline
error getLastError() { return ::oclGetLastError(); }

static inline
void *memset(void *cpuPtr, int c, size_t count) { return ::oclMemset(cpuPtr, c, count); }

static inline
void *memcpy(void *cpuDstPtr, const void *cpuSrcPtr, size_t count) {
    return ::oclMemcpy(cpuDstPtr, cpuSrcPtr, count);
}

static inline
void deviceSend(THREAD_T tid) { ::oclDeviceSend(tid); }

static inline
void deviceReceive(void) { ::oclDeviceReceive(); }

static inline
void deviceSendReceive(THREAD_T tid) { ::oclDeviceSendReceive(tid); }

static inline
void deviceCopy(THREAD_T tid) { ::oclDeviceCopy(tid); }

template<typename T>
static inline cl_mem ptr(const T *addr) {
    return ::oclPtr((const void *)addr);
}

#ifdef __cplusplus
}
#endif


#undef __dv

#endif /* OPENCL_H */

/* vim:set ft=cpp backspace=2 tabstop=4 shiftwidth=4 textwidth=120 foldmethod=marker expandtab: */
