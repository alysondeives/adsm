\section{Single\hyp{}Threaded Applications}

\subsection{Initialization}
GMAC\slash Lite requires data allocations to be performed over single\hyp{}device OpenCL contexts.  
This simple restriction allows the initialization of GMAC\slash Lite applications to be greatly 
simplified compared to regular OpenCL applications (Listing~\ref{lst:opencl:init}). GMAC\slash Lite 
offers a convenient API call (\texttt{oclLiteInit()}). This API call can be also combined with 
\texttt{oclLiteLoadProgramFromFile()} to further simplify the load and compilation of OpenCL kernels 
from external files. The combination of these both GMAC\slash Lite API calls can be combined as 
illustrated in Listing~\ref{lst:lite:load}.

\lstinputlisting[float,
    language=C,
    frame=tb,
    caption={GMAC\slash Lite code to make OpenCL code available to the application.},
    label={lst:lite:load}]{lite/load.c}

The \texttt{clLiteInit()} takes a reference to a \texttt{cl\_lite} variable. This variable is a 
structure that contains an array of platforms (\texttt{platforms}), the number of platforms 
(\texttt{num\_platforms}), an array of devices (\texttt{devices}), the number of devices 
(\texttt{num\_devices}), an array of contexts (\texttt{contexts}), which are bound to each of the 
devices in the system, and an array of command queues (\texttt{command\_queues}), which are bound to 
each of the contexts. GMAC\slash Lite applications are not required to use the \texttt{cl\_lite} 
structure and the \texttt{clLiteInit()}, but its usage reduces amount of application initialization 
code.

\subsection{Memory Allocation}
Memory allocation in GMAC\slash Lite is done using the \texttt{clMalloc()} API call, which returns a 
CPU pointer that can be used in any place of the CPU code. Listing~\ref{lst:lite:load} shows the 
GMAC\slash Lite code to allocate data structures using \texttt{clMalloc()}. In this example we use 
the same \texttt{load\_vector()} function used in Listing~\ref{lst:hpe:load}.

\lstinputlisting[float,
    language=C,
    frame=tb,
    caption={GMAC\slash Lite code to allocate and initialized the input and output vectors.},
    label={lst:lite:alloc}]{lite/alloc.c}

Calls to \texttt{clMalloc()} take as first parameter an OpenCL context.  
Listing~\ref{lst:lite:alloc} uses one of the contexts created by the call to \texttt{clLiteInit()}, 
but any valid OpenCL context might be used. Besides the OpenCL context, \texttt{clMalloc()} also 
takes a reference to the pointer where to store the address of the allocated memory, and the number 
of bytes of memory to be allocated.

\subsection{Kernel Calls}
Kernel calls in GMAC\slash Lite is very similar to both GMAC\slash HPE and OpenCL\@.  
Listing~\ref{lst:lite:call} shows the code to perform the kernel call, which uses 
\texttt{clBuffer()} to get the \texttt{cl\_mem} object associated to memory allocated through calls 
to \texttt{clMalloc()}.

\lstinputlisting[float,
    language=C,
    frame=tb,
    caption={GMAC\slash Lite code to call the vector addition kernel.},
    label={lst:lite:call}]{lite/call.c}

Calls to \texttt{clBuffer()} takes as first parameter the context which the memory belongs to, and 
as a second parameter, a CPU pointer returned by \texttt{clMalloc()}.  If an invalid pointer is 
passed as a parameter, \texttt{clBuffer()} returns a \texttt{cl\_mem} object initialized to 
\texttt{NULL} to signal the error condition.

\subsection{Memory Release}
Listing~\ref{lst:lite:release} shows the source code to release resources in GMAC\slash Lite. Memory 
is released calling \texttt{clFree()}, while all data structures associated with OpenCL are released 
calling to \texttt{clLiteRelease()}.

\lstinputlisting[float,
    language=C,
    frame=tb,
    caption={GMAC\slash Lite code to write the output vector and release memory.},
    label={lst:lite:release}]{lite/release.c}

Calls to \texttt{clFree()} require the OpenCL context where the memory was allocated 
(\texttt{lite.context[0]} in Listing~\ref{lst:lite:release}), and the CPU address returned by 
\texttt{clMalloc()}. If an OpenCL context other than the one where the memory was allocated is 
passed as a parameter to \texttt{clFree()}, an \texttt{CL\_INVALID\_CONTEXT} error is returned.

% vim: set spell ft=tex fo=aw2t expandtab sw=2 tw=100:
